#!/usr/bin/env bash
# merge-driver-catalog.sh — custom merge driver for files with
# auto-generated catalog sections (PLAN.md, README.md).
#
# Catalog sections between <!-- catalog --> and <!-- /catalog -->
# are fully regenerated by `mdsmith fix`. This driver strips
# conflict markers inside those blocks and lets mdsmith fix
# rebuild the correct table. Non-catalog conflicts are left
# for manual resolution.
#
# Usage (configured via .gitattributes + git config):
#   [merge "catalog"]
#     name = Catalog-aware Markdown merge
#     driver = scripts/merge-driver-catalog.sh %O %A %B %P
#
# Arguments:
#   $1 = %O (ancestor / base)
#   $2 = %A (ours — also the output file)
#   $3 = %B (theirs)
#   $4 = %P (pathname, optional)

set -euo pipefail

BASE="$1"
OURS="$2"
THEIRS="$3"
PATHNAME="${4:-}"

# Step 1: attempt standard 3-way merge.
# git merge-file exits 0 on clean merge, >0 on conflicts.
if git merge-file "$OURS" "$BASE" "$THEIRS" 2>/dev/null; then
  if command -v mdsmith >/dev/null 2>&1 && [ -n "$PATHNAME" ]; then
    mdsmith fix "$PATHNAME" 2>/dev/null || true
  fi
  exit 0
fi

# Step 2: conflicts detected. Strip conflict markers inside
# catalog blocks — mdsmith fix regenerates the content anyway.
awk '
/^<!-- catalog/ { in_catalog = 1 }
/^<!-- \/catalog -->/ { in_catalog = 0 }
in_catalog && /^(<<<<<<<|=======|>>>>>>>)/ { next }
{ print }
' "$OURS" > "${OURS}.tmp"
mv "${OURS}.tmp" "$OURS"

# Step 3: let mdsmith fix rebuild catalog sections.
if command -v mdsmith >/dev/null 2>&1 && [ -n "$PATHNAME" ]; then
  mdsmith fix "$PATHNAME" 2>/dev/null || true
fi

# Step 4: check for remaining conflict markers outside catalogs.
if grep -q '^<<<<<<<' "$OURS" 2>/dev/null; then
  exit 1
fi

exit 0
